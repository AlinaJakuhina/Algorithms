// 1)Даны два целых числа x и n, напишите функцию для вычисления x^n
// решение 1 - рекурсивно O(n)
// решение 2 - улучшить решение 1 до O(lon n)

// 1)
// def power(x, n):
//     if n == 0:
//         return 1
//     return x * power(x, n-1)
// 2)
// def power(x, n):
//     if n == 0:
//         return 1
//     elif n % 2 == 0:
//         return power(x*x, n/2)
//     else:
//         return x * power(x, n-1)

// ------------
//2) Имея два отсортированных массива размера m и n соответственно, вам нужно найти элемент, который будет находиться на k-й позиции в конечном отсортированном массиве.
// Массив 1 - 100 112 256 349 770
// Массив 2 - 72 86 113 119 265 445 892
// к = 7
// Вывод : 256
// Окончательный отсортированный массив -
// 72, 86, 100, 112, 113, 119, 256, 265, 349, 445, 770, 892
// 7-й элемент этого массива равен 256.


// В этом случае мы должны начать со сравнения 100 и 72, добавления 72 к окончательному отсортированному массиву и увеличения индекса для второго массива. Затем мы сравниваем 112 и 86, добавив 86 и увеличив индекс для первого массива. Повторять этот процесс, пока седьмой элемент не будет добавлен в окончательный отсортированный массив, равный 256.

// ----------------

// 3)Имея отсортированный массив arr[] и число x, напишите функцию, которая подсчитывает вхождения x в arr[]. Ожидаемая временная сложность O(Log n)
// arr[] = {1, 1, 2, 2, 2, 2, 3,} 
// x = 2
// Вывод: 4 раза

// def count_x(arr, x):
//     first_x = -1
//     last_x = -1
//     left = 0
//     right = len(arr) - 1
    
//     # Find the first occurrence of x
//     while left <= right:
//         mid = (left + right) // 2
//         if arr[mid] >= x:
//             if arr[mid] == x:
//                 first_x = mid
//             right = mid - 1
//         else:
//             left = mid + 1
    
//     # If x is not present in arr
//     if first_x == -1:
//         return 0
    
//     left = 0
//     right = len(arr) - 1
    
//     # Find the last occurrence of x
//     while left <= right:
//         mid = (left + right) // 2
//         if arr[mid] <= x:
//             if arr[mid] == x:
//                 last_x = mid
//             left = mid + 1
//         else:
//             right = mid - 1
    
//     return last_x - first_x + 1

// arr = [1, 1, 2, 2, 2, 2, 3]
// x = 2
// print(count_x(arr, x))


// 4* Найдите пиковый элемент в двумерном массиве
// Элемент является пиковым, если он больше или равен своим четырем соседям слева, справа, сверху и снизу. Например, соседями для A[i][j] являются A[i-1][j], A[i+1][j], A[i][j-1] и A[i][j+1 ]. Для угловых элементов отсутствующие соседи считаются отрицательными бесконечными значениями.
// 10 20 15
// 21 30 14
//  7 16 32
// Выход: 30
// 30 — пиковый элемент, потому что все его
// соседи меньше или равны ему.
// 32 также можно выбрать в качестве пика.


// note
// 1 Смежная диагональ не считается соседней. 
// 2 Пиковый элемент не обязательно является максимальным элементом. 
// 3 Таких элементов может быть несколько. 
// 4 Всегда есть пиковый элемент.


// Second level: 


не могу решить